# 命令模式



## 需求



---

## 实现



将封装提升到一个全新的境界：把方法调用(method invocation)封装起来

通过封装**方法调用**，实现比如记录日志，或者重复使用这些封装来实现撤销。



设计一组控制遥控器的API，让每个卡槽可以控制一个或一组装置

有一个开关按钮的遥控器和一套五花八门的厂商类（on(), off(), setTemperature(), setVolumn()等），而且还会有更多的厂商类。



```java
if (slot1 == Light) 
  then lighton;
if (slot1 == Hottub)
  then hottob.jetsOn();
```

命令模式：将“动作的请求者”从“动作的执行者“对象中解耦出来。（请求者：遥控器，执行者：具体的一个家电，比如电灯对象）

命令对象：把一个请求(比如打开台灯）封装成特定对象（比如客厅台灯对象）。每一个按钮都存储一个命令对象，当按钮被按下，由命令对象做相关操作。而遥控器不需要知道具体的工作是什么，只有命令对象能和正确的对象沟通。

**请求者（遥控器） -> 命令对象 -> 执行者（家电对象）**





---

将请求封装成一个对象：对象中有请求的接收者(Light对象)和接收者要执行的命令(`Light.on()`)，这个命令对象只暴露一个execute()方法





一张订单封装了点餐请求，只有一个orderUp()方法，里面封装了准备餐点所需的动作。





以下单为例子

- 一个订单对象封装了具体的请求
- 女服务员， 只需要接收订单，然后执行`orderUp()`。不需要关心订单的内容是啥
- 快餐厨师，知道具体的如何准备食物

女服务员和厨师之间彻底解耦，也就是**发出请求的对象**和**接受与执行请求的对象**之间解耦。



| Client       | 顾客          |                |
| ------------ | ----------- | -------------- |
| setCommand() | takeOrder() |                |
| Command      | 订单          | LightOnCommand |
| execute()    | orderUp()   |                |
| Invoker      | 女服务员        | 遥控器            |
| Receiver     | 厨师          | 电灯、音箱等等        |

